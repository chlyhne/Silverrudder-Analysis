#!/usr/bin/env python3
"""
Generate per-skipper report sources and optionally compile them.

Output:
- Pair include files: documentation/report-pairs/<boat-slug>.tex
- Entry files: documentation/report-sources/main-{pc|phone}-<boat-slug>.tex
- PDFs (optional compile): documentation/reports-pdf/
- LaTeX temp files (optional compile): documentation/reports-tmp/

This script is OS-agnostic and works on Linux/Windows/macOS as long as Python
is available. If --compile is used, latexmk must be available on PATH.
"""

from __future__ import annotations

import argparse
import subprocess
import sys
from pathlib import Path
from typing import Iterable, List

ROOT = Path(__file__).resolve().parents[1]
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

import silver_helpers as sh

DOC_DIR = ROOT / "documentation"
DATA_DIR = ROOT / "data" / "silverrudder_2025"
TRACKING_CSV = DATA_DIR / "Silverrudder 2025_Keelboats Small_gps_data.csv"
RACE_META = DATA_DIR / "race_metadata.json"

PAIR_INCLUDE_DIR = DOC_DIR / "report-pairs"
SOURCE_DIR = DOC_DIR / "report-sources"
PDF_DIR = DOC_DIR / "reports-pdf"
TMP_DIR = DOC_DIR / "reports-tmp"
FIGURE_GENERATION_LOCK_PATTERN = ".figures-generating*.lock"


def latex_label(name: str) -> str:
    """Return a LaTeX-safe display label for report text."""
    if name == "Aegir 2.0":
        return "Ã†gir 2.0"
    if name == "Nordri":
        return r"Nor\dh ri"
    return sh.escape_latex_text(name)


def load_report_boat_names() -> List[str]:
    """
    Discover the active boats from the tracking CSV + metadata mapping.

    Using the same helper flow as the analysis code keeps report generation
    aligned with the boats that actually exist in the dataset (13 boats here).
    """
    race_meta = sh.load_race_metadata(RACE_META)
    track_name_map = {
        track_id: boat_name
        for track_id, boat_name in zip(race_meta["track_id_keys"], race_meta["boat_names"])
    }
    tracking_data = sh.read_tracking_csv_as_struct(str(TRACKING_CSV))
    tracks = sh.build_tracks(
        tracking_data,
        "tracked_object_id",
        "Latitude",
        "Longitude",
        "SampleTime",
        "Speed",
    )
    tracks = sh.apply_track_names(tracks, track_name_map)
    return [str(track.get("name", "")).strip() for track in tracks if str(track.get("name", "")).strip()]


def write_text(path: Path, content: str) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content, encoding="utf-8")


def generate_pair_include(report_boat: str, all_boats: Iterable[str]) -> str:
    """
    Create the per-boat comparison section include.

    Order is intentionally report_boat vs other_boat for each subsection.
    """
    report_slug = sh.sanitize_filename_label(report_boat)
    report_display = latex_label(report_boat)
    others = [boat for boat in all_boats if boat != report_boat]

    lines = [
        "% Auto-generated by documentation/build_skipper_reports.py",
        f"% Comparisons for {report_boat}",
        "",
    ]
    for index, other_boat in enumerate(others):
        other_slug = sh.sanitize_filename_label(other_boat)
        other_display = latex_label(other_boat)

        lines.extend(
            [
                f"\\subsection*{{{report_display} vs {other_display}}}",
                "\\begin{figure}[H]",
                "\\centering",
                f"\\includegraphics{{figures/\\figurevariant/pace-delta-pair-{report_slug}-vs-{other_slug}.pdf}}",
                f"\\caption{{Pace delta by leg: {report_display} (left half) vs {other_display} (right half).}}",
                "\\end{figure}",
                "\\begin{figure}[H]",
                "\\centering",
                f"\\includegraphics{{figures/\\figurevariant/speed-delta-pair-{report_slug}-vs-{other_slug}.pdf}}",
                f"\\caption{{Speed delta by leg: {report_display} (left half) vs {other_display} (right half).}}",
                "\\end{figure}",
            ]
        )
        if index < len(others) - 1:
            lines.extend(["\\sectionbreak", ""])

    lines.append("")
    return "\n".join(lines)


def generate_entry_tex(report_boat: str, phone_layout: bool) -> str:
    """Create one top-level .tex entry file for a single skipper + layout."""
    boat_slug = sh.sanitize_filename_label(report_boat)
    boat_display = latex_label(report_boat)

    lines = [
        "\\documentclass[11pt]{article}",
        "% Auto-generated by documentation/build_skipper_reports.py",
    ]
    if phone_layout:
        lines.append("\\def\\phonepdftrueoverride{1}")

    lines.extend(
        [
            f"\\def\\reportboatname{{{boat_display}}}",
            f"\\def\\reportboatslug{{{boat_slug}}}",
            "\\makeatletter",
            "\\def\\input@path{{./}{documentation/}}",
            "\\makeatother",
            "\\input{main-shared.tex}",
            "",
        ]
    )
    return "\n".join(lines)


def generate_sources(boat_names: List[str]) -> List[Path]:
    """Generate all pair include files and both layout entry files per boat."""
    generated_entries: List[Path] = []
    PAIR_INCLUDE_DIR.mkdir(parents=True, exist_ok=True)
    SOURCE_DIR.mkdir(parents=True, exist_ok=True)

    for report_boat in boat_names:
        boat_slug = sh.sanitize_filename_label(report_boat)

        pair_include_content = generate_pair_include(report_boat, boat_names)
        pair_include_path = PAIR_INCLUDE_DIR / f"{boat_slug}.tex"
        write_text(pair_include_path, pair_include_content)

        pc_entry_path = SOURCE_DIR / f"main-pc-{boat_slug}.tex"
        phone_entry_path = SOURCE_DIR / f"main-phone-{boat_slug}.tex"
        write_text(pc_entry_path, generate_entry_tex(report_boat, phone_layout=False))
        write_text(phone_entry_path, generate_entry_tex(report_boat, phone_layout=True))
        generated_entries.extend([pc_entry_path, phone_entry_path])

    return generated_entries


def compile_reports(entries: List[Path], latexmk_cmd: str) -> None:
    """Compile all generated entry files with separate PDF and temp directories."""
    PDF_DIR.mkdir(parents=True, exist_ok=True)
    TMP_DIR.mkdir(parents=True, exist_ok=True)

    for entry_path in entries:
        cmd = [
            latexmk_cmd,
            "-pdf",
            "-interaction=nonstopmode",
            "-halt-on-error",
            f"-outdir={PDF_DIR}",
            f"-auxdir={TMP_DIR}",
            str(entry_path),
        ]
        subprocess.run(cmd, cwd=ROOT, check=True)


def iter_expected_pair_figure_paths(boat_names: List[str]) -> Iterable[Path]:
    """
    Yield all expected pair figure paths for both desktop + phone variants.

    We check these before compilation to avoid burning CPU in LaTeX when figure
    generation is still in progress.
    """
    boat_slugs = [sh.sanitize_filename_label(name) for name in boat_names]
    for variant in ("desktop", "phone"):
        for left_slug in boat_slugs:
            for right_slug in boat_slugs:
                if left_slug == right_slug:
                    continue
                yield DOC_DIR / "figures" / variant / f"pace-delta-pair-{left_slug}-vs-{right_slug}.pdf"
                yield DOC_DIR / "figures" / variant / f"speed-delta-pair-{left_slug}-vs-{right_slug}.pdf"


def iter_expected_shared_figure_paths() -> Iterable[Path]:
    """Yield expected shared (non-pair) figures required by main-shared.tex."""
    for variant in ("desktop", "phone"):
        yield DOC_DIR / "figures" / variant / "time-delta-along-route.pdf"


def find_missing_required_figures(boat_names: List[str]) -> List[Path]:
    """Return all expected figures referenced by reports that are missing on disk."""
    missing_paths: List[Path] = []
    for figure_path in iter_expected_pair_figure_paths(boat_names):
        if not figure_path.exists():
            missing_paths.append(figure_path)
    for figure_path in iter_expected_shared_figure_paths():
        if not figure_path.exists():
            missing_paths.append(figure_path)
    return missing_paths


def find_active_figure_locks() -> List[Path]:
    """Return all active figure-generation lock files."""
    return sorted(DOC_DIR.glob(FIGURE_GENERATION_LOCK_PATTERN))


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Generate and optionally compile per-skipper Silverrudder reports."
    )
    parser.add_argument(
        "--compile",
        action="store_true",
        help="Compile generated reports with latexmk after source generation.",
    )
    parser.add_argument(
        "--latexmk",
        default="latexmk",
        help="latexmk executable name/path (default: latexmk).",
    )
    parser.add_argument(
        "--skip-figure-check",
        action="store_true",
        help="Compile even when expected pair figures are missing.",
    )
    parser.add_argument(
        "--ignore-figure-lock",
        action="store_true",
        help="Compile even if figure generation lock file is present.",
    )
    return parser.parse_args()


def main() -> int:
    args = parse_args()
    boat_names = load_report_boat_names()
    entries = generate_sources(boat_names)

    if args.compile:
        active_locks = find_active_figure_locks()
        if active_locks and not args.ignore_figure_lock:
            print(
                "ERROR: Figure generation appears to be running "
                f"({len(active_locks)} lock file(s) present).",
                file=sys.stderr,
            )
            for lock_path in active_locks[:5]:
                print(f"  - {lock_path}", file=sys.stderr)
            if len(active_locks) > 5:
                print(f"  ... and {len(active_locks) - 5} more", file=sys.stderr)
            print(
                "Wait for silver.py to finish before compiling reports, "
                "or use --ignore-figure-lock to force compile.",
                file=sys.stderr,
            )
            return 3

        if not args.skip_figure_check:
            missing_paths = find_missing_required_figures(boat_names)
            if missing_paths:
                print(
                    f"ERROR: {len(missing_paths)} required pair figures are missing. "
                    "Figure generation appears incomplete.",
                    file=sys.stderr,
                )
                preview_count = min(20, len(missing_paths))
                for missing_path in missing_paths[:preview_count]:
                    print(f"  - {missing_path}", file=sys.stderr)
                if len(missing_paths) > preview_count:
                    print(
                        f"  ... and {len(missing_paths) - preview_count} more",
                        file=sys.stderr,
                    )
                print(
                    "Run report compilation again after figure generation is finished, "
                    "or use --skip-figure-check to force compile.",
                    file=sys.stderr,
                )
                return 2
        try:
            compile_reports(entries, args.latexmk)
        except FileNotFoundError:
            print(
                f"ERROR: latexmk executable not found: {args.latexmk}",
                file=sys.stderr,
            )
            return 1
        except subprocess.CalledProcessError as exc:
            print(f"ERROR: latexmk failed with exit code {exc.returncode}", file=sys.stderr)
            return exc.returncode

    print(f"Generated {len(entries)} entry files for {len(boat_names)} boats.")
    print(f"Pair include files: {PAIR_INCLUDE_DIR}")
    print(f"Entry files: {SOURCE_DIR}")
    if args.compile:
        print(f"PDF output: {PDF_DIR}")
        print(f"LaTeX temp output: {TMP_DIR}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
